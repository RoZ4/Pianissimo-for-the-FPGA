`timescale 1ns / 1ps

module testbench ( );

	parameter CLOCK_PERIOD = 10;

    reg [9:0] SW;
    //reg [3:0] KEY;
    reg CLOCK_50;
    wire [32:0] sound;
    wire [32:0] delay;

	initial begin
        CLOCK_50 <= 1'b0;
	end // initial
	always @ (*)
	begin : Clock_Generator
		#((CLOCK_PERIOD) / 2) CLOCK_50 <= ~CLOCK_50;
	end
	
    /*
	initial begin
        KEY[0] <= 1'b0;
        #10 KEY[0] <= 1'b1;
	end */// initial

    // In the setup below we assume that the half_sec_enable signal coming
    // from the half-second clock is asserted every 3 cycles of CLOCK_50. Of
    // course, in the real circuit the half-second clock is asserted every
    // 25M cycles. The setup below produces the Morse code for A (.-) followed
    // by the Morse code for B (-...).
	initial begin
        #10 SW[9:0] <= 10'b0000000000;
        #10 SW[9:0] <= 10'b0000000001;
        #10 SW[9:0] <= 10'b0000000010;
        #10 SW[9:0] <= 10'b0000000100; 
        #10 SW[9:0] <= 10'b0000001000;
        #10 SW[9:0] <= 10'b0000010000;
        #10 SW[9:0] <= 10'b0000100000;
        #10 SW[9:0] <= 10'b0001000000;
        #10 SW[9:0] <= 10'b0010000000;
        #10 SW[9:0] <= 10'b0100000000;

	end // initial
	pianosimpleformodelsim U1 (
	// Inputs
	CLOCK_50,
	SW, sound
);

        //initial begin $monitor("time=%0d, reset=%b, counter=%d, hex=%7b", $time, KEY[0], slowCounterOut, HEX0); end 

endmodule